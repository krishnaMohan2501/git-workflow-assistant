#!/bin/bash

# Intelligent Common Branch Workflow
# Usage: ./git-workflow.sh <common-branch-name> [feature-branch-name]

# Configuration
MASTER_BRANCH="master"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Logging functions
log_step() {
    local step_number="$1"
    local step_description="$2"
    echo ""
    echo -e "${CYAN}===========================================${NC}"
    echo -e "${CYAN}üìã STEP $step_number: $step_description${NC}"
    echo -e "${CYAN}===========================================${NC}"
}

log_action() {
    local action="$1"
    echo -e "${BLUE}üîß ACTION: $action${NC}"
}

log_success() {
    local message="$1"
    echo -e "${GREEN}‚úÖ SUCCESS: $message${NC}"
}

log_warning() {
    local message="$1"
    echo -e "${YELLOW}‚ö†Ô∏è  WARNING: $message${NC}"
}

log_error() {
    local message="$1"
    echo -e "${RED}‚ùå ERROR: $message${NC}"
}

# Enhanced execute Copilot command with proper branch name resolution
execute_copilot() {
    local description="$1"
    local temp_file="/tmp/git_cmd"
    
    log_action "Asking Copilot: $description"
    
    # Use the exact working pattern you discovered
    gh copilot suggest -t git -s "$temp_file" "$description"
    local copilot_exit_code=$?
    
    # Check if user exited Copilot
    if [ $copilot_exit_code -ne 0 ]; then
        log_error "Copilot command cancelled or failed"
        echo -e "${RED}‚ùå WORKFLOW STOPPED - User cancelled or Copilot failed${NC}"
        rm -f "$temp_file"
        exit 1
    fi
    
    # Check if command was generated
    if [ -f "$temp_file" ] && [ -s "$temp_file" ]; then
        local cmd=$(cat "$temp_file")
        echo -e "${GREEN}üöÄ EXECUTING: $cmd${NC}"
        
        # Check for placeholder patterns and resolve them
        if [[ "$cmd" =~ \<.*\> ]]; then
            cmd=$(resolve_command_placeholders "$cmd")
            if [ $? -ne 0 ]; then
                log_error "Failed to resolve command placeholders"
                rm -f "$temp_file"
                return 1
            fi
            echo -e "${GREEN}üîß RESOLVED: $cmd${NC}"
        fi
        
        # Execute the resolved command
        eval "$cmd"
        local exit_code=$?
        
        if [ $exit_code -eq 0 ]; then
            log_success "Command executed successfully"
        else
            log_error "Command failed with exit code $exit_code"
            show_error_troubleshooting "$cmd" "$exit_code"
            rm -f "$temp_file"
            exit 1
        fi
        
        # Clean up
        rm -f "$temp_file"
        return $exit_code
    else
        log_warning "No command generated by Copilot"
        echo -e "${RED}‚ùå WORKFLOW STOPPED - No command to execute${NC}"
        rm -f "$temp_file"
        exit 1
    fi
}

# Function to resolve command placeholders
resolve_command_placeholders() {
    local cmd="$1"
    local resolved_cmd="$cmd"
    
    # Get current branch for reference
    local current_branch=$(git branch --show-current 2>/dev/null)
    
    # Resolve common placeholders
    if [[ "$resolved_cmd" =~ \<branch-name\>|\<target-branch\>|\<upstream-branch\> ]]; then
        # Try to determine appropriate branch from context
        if [[ "$resolved_cmd" =~ "origin/" ]]; then
            # For origin operations, use current branch
            resolved_cmd=$(echo "$resolved_cmd" | sed "s/<[^>]*branch[^>]*>/$current_branch/g")
        else
            # For local operations, prompt user
            echo "Available branches:"
            git branch -a | head -10
            read -p "Enter branch name (default: $current_branch): " branch_name
            branch_name="${branch_name:-$current_branch}"
            resolved_cmd=$(echo "$resolved_cmd" | sed "s/<[^>]*branch[^>]*>/$branch_name/g")
        fi
    fi
    
    if [[ "$resolved_cmd" =~ \<commit\>|\<commit-hash\> ]]; then
        echo "Recent commits:"
        git log --oneline -5
        read -p "Enter commit hash: " commit_hash
        if [ -n "$commit_hash" ]; then
            resolved_cmd=$(echo "$resolved_cmd" | sed "s/<[^>]*commit[^>]*>/$commit_hash/g")
        else
            echo "No commit hash provided"
            return 1
        fi
    fi
    
    if [[ "$resolved_cmd" =~ \<message\>|\<commit-message\> ]]; then
        read -p "Enter commit message: " commit_msg
        if [ -n "$commit_msg" ]; then
            resolved_cmd=$(echo "$resolved_cmd" | sed "s/<[^>]*message[^>]*>/\"$commit_msg\"/g")
        else
            echo "No commit message provided"
            return 1
        fi
    fi
    
    if [[ "$resolved_cmd" =~ \<file\>|\<filename\> ]]; then
        echo "Modified files:"
        git status --porcelain
        read -p "Enter filename: " filename
        if [ -n "$filename" ]; then
            resolved_cmd=$(echo "$resolved_cmd" | sed "s/<[^>]*file[^>]*>/$filename/g")
        else
            echo "No filename provided"
            return 1
        fi
    fi
    
    # Check if any placeholders remain
    if [[ "$resolved_cmd" =~ \<.*\> ]]; then
        echo -e "${RED}‚ùå Unresolved placeholders remain in: $resolved_cmd${NC}"
        read -p "Enter the complete command manually: " manual_cmd
        if [ -n "$manual_cmd" ]; then
            resolved_cmd="$manual_cmd"
        else
            return 1
        fi
    fi
    
    echo "$resolved_cmd"
    return 0
}

# Show error troubleshooting based on command type and exit code
show_error_troubleshooting() {
    local cmd="$1"
    local exit_code="$2"
    
    echo ""
    echo -e "${YELLOW}**üí° Troubleshooting suggestions:**${NC}"
    
    if [[ "$cmd" =~ "merge" ]] && [ "$exit_code" -eq 1 ]; then
        echo "  ‚Ä¢ There might be merge conflicts. Try: 'show merge conflicts'"
        echo "  ‚Ä¢ You might need to commit changes first"
    elif [[ "$cmd" =~ "rebase" ]] && [ "$exit_code" -eq 1 ]; then
        echo "  ‚Ä¢ There might be rebase conflicts that need resolution"
        echo "  ‚Ä¢ You might need to commit or stash changes first"
        echo "  ‚Ä¢ The target branch might not exist or be accessible"
    elif [[ "$cmd" =~ "push" ]] && [ "$exit_code" -eq 1 ]; then
        echo "  ‚Ä¢ Remote branch might not exist. Try: 'push and set upstream'"
        echo "  ‚Ä¢ You might need to pull first. Try: 'pull latest changes'"
        echo "  ‚Ä¢ Branch might be protected or you lack permissions"
    elif [[ "$cmd" =~ "checkout|switch" ]] && [ "$exit_code" -eq 1 ]; then
        echo "  ‚Ä¢ Branch might not exist locally or remotely"
        echo "  ‚Ä¢ You might have uncommitted changes. Try: 'stash changes first'"
    elif [[ "$cmd" =~ "pull|fetch" ]] && [ "$exit_code" -eq 1 ]; then
        echo "  ‚Ä¢ Remote repository might be unreachable"
        echo "  ‚Ä¢ Branch might not exist on remote"
        echo "  ‚Ä¢ Network connectivity issues"
    else
        echo "  ‚Ä¢ Check repository status: git status"
        echo "  ‚Ä¢ Verify you're in a git repository"
        echo "  ‚Ä¢ Check if remote is configured: git remote -v"
    fi
}

# Execute git command directly with better error handling
execute_git() {
    local cmd="$1"
    local description="$2"
    
    if [ -n "$description" ]; then
        log_action "$description"
    fi
    
    echo -e "${GREEN}üöÄ EXECUTING: $cmd${NC}"
    
    # Check for placeholder patterns before execution
    if [[ "$cmd" =~ \<.*\> ]]; then
        log_error "Command contains unresolved placeholders: $cmd"
        local resolved_cmd=$(resolve_command_placeholders "$cmd")
        if [ $? -eq 0 ]; then
            cmd="$resolved_cmd"
            echo -e "${GREEN}üîß RESOLVED: $cmd${NC}"
        else
            log_error "Failed to resolve placeholders"
            return 1
        fi
    fi
    
    eval "$cmd"
    local exit_code=$?
    
    if [ $exit_code -eq 0 ]; then
        log_success "Command completed successfully"
    else
        log_error "Command failed with exit code $exit_code"
        show_error_troubleshooting "$cmd" "$exit_code"
    fi
    
    return $exit_code
}

# Check if we're in a git repository
check_git_repo() {
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        log_error "Not in a git repository!"
        exit 1
    fi
}

# Check if branch exists locally
branch_exists_locally() {
    local branch="$1"
    git show-ref --verify --quiet refs/heads/"$branch" 2>/dev/null
}

# Check if branch exists on remote
branch_exists_remotely() {
    local branch="$1"
    git show-ref --verify --quiet refs/remotes/origin/"$branch" 2>/dev/null
}

# Get commits that are unique to a branch
get_unique_commits() {
    local source_branch="$1"
    local target_branch="$2"
    git rev-list --oneline "$target_branch..$source_branch" 2>/dev/null
}

# Check for merge conflicts
has_conflicts() {
    git status --porcelain | grep -q "^UU\|^AA\|^DD"
}

# Get list of conflicted files
get_conflicted_files() {
    git status --porcelain | grep "^UU\|^AA\|^DD" | sed 's/^..//'
}

# Enhanced automatic conflict resolution with smart version handling
auto_resolve_version_conflicts() {
    local file="$1"
    
    log_action "Auto-resolving version conflicts in: $file"
    
    # Create backup
    cp "$file" "${file}.backup"
    
    # Use Python for smart version conflict resolution
    python3 << EOF
import re
import sys

def compare_versions(v1, v2):
    """Compare two version strings and return the higher one"""
    try:
        # Simple version comparison for most cases
        v1_parts = [int(x) for x in v1.split('.')]
        v2_parts = [int(x) for x in v2.split('.')]
        
        # Pad shorter version with zeros
        max_len = max(len(v1_parts), len(v2_parts))
        v1_parts.extend([0] * (max_len - len(v1_parts)))
        v2_parts.extend([0] * (max_len - len(v2_parts)))
        
        if v1_parts >= v2_parts:
            return v1
        else:
            return v2
    except:
        # If version parsing fails, use string comparison as fallback
        if v1 >= v2:
            return v1
        else:
            return v2

def resolve_version_conflicts(content):
    """Automatically resolve version conflicts by choosing higher versions"""
    
    # Pattern to match conflict blocks with versions
    conflict_pattern = r'<<<<<<< HEAD\n(.*?)\n=======\n(.*?)\n>>>>>>> .*?\n'
    
    def replace_conflict(match):
        our_section = match.group(1).strip()
        their_section = match.group(2).strip()
        
        # Check if this is a version conflict
        our_version_match = re.search(r'<version>([\d\.]+)</version>', our_section)
        their_version_match = re.search(r'<version>([\d\.]+)</version>', their_section)
        
        if our_version_match and their_version_match:
            our_version = our_version_match.group(1)
            their_version = their_version_match.group(1)
            
            # Choose the higher version
            chosen_version = compare_versions(our_version, their_version)
            
            print(f"Version conflict: {our_version} vs {their_version} -> chose {chosen_version}")
            
            if chosen_version == our_version:
                return our_section + '\n'
            else:
                return their_section + '\n'
        
        # For non-version conflicts, try to merge intelligently
        else:
            # If sections are similar, try to combine
            if our_section == their_section:
                return our_section + '\n'
            
            # For different content, prefer ours (current branch) in rebase
            print(f"Non-version conflict resolved by keeping current branch version")
            return our_section + '\n'
    
    # Replace all conflict blocks
    resolved_content = re.sub(conflict_pattern, replace_conflict, content, flags=re.DOTALL)
    
    return resolved_content

try:
    with open('$file', 'r') as f:
        content = f.read()
    
    # Check if file has conflicts
    if '<<<<<<< HEAD' not in content:
        print("No conflicts found in file")
        sys.exit(0)
    
    print(f"Resolving conflicts in $file...")
    
    # Resolve conflicts
    resolved_content = resolve_version_conflicts(content)
    
    # Write resolved content
    with open('$file', 'w') as f:
        f.write(resolved_content)
    
    # Verify no conflict markers remain
    if '<<<<<<< HEAD' not in resolved_content:
        print(f"‚úÖ Successfully auto-resolved all conflicts in $file")
        sys.exit(0)
    else:
        print(f"‚ùå Some conflicts could not be auto-resolved in $file")
        sys.exit(1)
        
except Exception as e:
    print(f"‚ùå Error during auto-resolution: {e}")
    sys.exit(1)
EOF
    
    local python_exit_code=$?
    
    if [ $python_exit_code -eq 0 ]; then
        # Auto-resolution succeeded
        log_success "Auto-resolved conflicts in $file"
        git add "$file"
        rm -f "${file}.backup"
        return 0
    else
        # Auto-resolution failed, restore backup
        log_warning "Auto-resolution failed for $file, trying simpler approach"
        mv "${file}.backup" "$file"
        
        # Try simpler approach - just take the newer versions for pom.xml
        if [[ "$file" == *"pom.xml" ]]; then
            log_action "Trying simple version conflict resolution for $file"
            
            # For pom.xml, in rebase context, usually take "ours" (current branch versions)
            if git checkout --ours "$file" 2>/dev/null; then
                log_success "Resolved $file by taking current branch version"
                git add "$file"
                return 0
            fi
        fi
        
        return 1
    fi
}

# Completely automatic conflict resolution
resolve_conflicts_automatically() {
    local conflicted_files=$(get_conflicted_files)
    
    if [ -z "$conflicted_files" ]; then
        log_success "No conflicts to resolve"
        return 0
    fi
    
    log_action "ü§ñ AUTOMATIC CONFLICT RESOLUTION STARTING"
    log_action "Found conflicts in files:"
    echo "$conflicted_files" | sed 's/^/  /'
    echo ""
    
    local all_resolved=true
    
    # Process each conflicted file automatically
    echo "$conflicted_files" | while read -r file; do
        if [ -f "$file" ]; then
            echo ""
            log_action "üîß Auto-resolving: $file"
            
            # Try smart version resolution first
            if auto_resolve_version_conflicts "$file"; then
                log_success "‚úÖ Auto-resolved: $file"
            else
                log_warning "‚ùå Could not auto-resolve: $file"
                
                # Fallback strategies
                if [[ "$file" == *"pom.xml" ]]; then
                    log_action "Applying POM.xml fallback strategy"
                    
                    # For pom.xml, take current branch version (usually newer)
                    if git checkout --ours "$file"; then
                        git add "$file"
                        log_success "‚úÖ Resolved $file using 'ours' strategy"
                    else
                        log_error "‚ùå Failed to resolve $file"
                        all_resolved=false
                    fi
                else
                    # For other files, try ours first, then theirs
                    if git checkout --ours "$file"; then
                        git add "$file"
                        log_success "‚úÖ Resolved $file using 'ours' strategy"
                    elif git checkout --theirs "$file"; then
                        git add "$file"
                        log_success "‚úÖ Resolved $file using 'theirs' strategy"
                    else
                        log_error "‚ùå Failed to resolve $file"
                        all_resolved=false
                    fi
                fi
            fi
        fi
    done
    
    # Check if all files were resolved
    if has_conflicts; then
        log_error "Some conflicts remain unresolved"
        echo ""
        echo -e "${CYAN}Remaining conflicts:${NC}"
        get_conflicted_files | sed 's/^/  /'
        return 1
    else
        log_success "üéâ ALL CONFLICTS RESOLVED AUTOMATICALLY!"
        return 0
    fi
}

# Create common branch with PR setup
create_common_branch() {
    local common_branch="$1"
    
    log_action "Creating common branch '$common_branch'"
    
    read -p "Create '$common_branch' from which branch? (default: $MASTER_BRANCH): " source_branch
    source_branch="${source_branch:-$MASTER_BRANCH}"
    
    # Step 1: Checkout source branch and pull latest
    execute_copilot "checkout to $source_branch branch"
    sleep 1
    execute_copilot "pull latest changes from origin $source_branch branch"
    sleep 1
    
    # Step 2: Create new branch
    execute_copilot "create new branch $common_branch from $source_branch"
    sleep 1
    
    # Step 3: Create empty commit to establish the branch
    log_action "Creating initial empty commit for branch establishment"
    local commit_message="feat: initialize $common_branch branch for collaborative development"
    
    if execute_git "git commit --allow-empty -m \"$commit_message\"" "Creating empty commit"; then
        log_success "Empty commit created successfully"
    else
        log_warning "Empty commit failed, but continuing..."
    fi
    
    # Step 4: Push branch to origin with upstream tracking
    execute_copilot "push new branch $common_branch to origin with upstream tracking"
    sleep 1
    
    # Step 5: Automatically create PR
    create_pull_request_for_branch "$common_branch" "$source_branch"
}

# Create pull request for the common branch
create_pull_request_for_branch() {
    local branch="$1"
    local base_branch="$2"
    
    log_action "Creating Pull Request for '$branch'"
    
    # Check if gh CLI is available
    if ! command -v gh >/dev/null 2>&1; then
        log_warning "GitHub CLI (gh) not found. Skipping automatic PR creation."
        echo ""
        echo -e "${YELLOW}üí° Manual PR Creation:${NC}"
        echo "  1. Go to your repository on GitHub"
        echo "  2. Click 'New Pull Request'"
        echo "  3. Select '$branch' ‚Üí '$base_branch'"
        echo "  4. Add title: 'feat: $branch - collaborative development branch'"
        echo ""
        return 1
    fi
    
    # Ask user if they want to create PR
    read -p "Create Pull Request for '$branch' ‚Üí '$base_branch'? (Y/n): " create_pr
    if [[ $create_pr =~ ^[Nn]$ ]]; then
        log_warning "Skipping PR creation as requested"
        return 0
    fi
    
    # Generate PR details
    local pr_title="feat: $branch - collaborative development branch"
    local pr_body="## üöÄ Common Development Branch: \`$branch\`

This is a collaborative development branch created for team integration.

### üìã Purpose:
- Consolidate features from multiple developers
- Maintain clean commit history via rebase workflow  
- Enable collaborative development while keeping master stable

### üîÑ Workflow:
1. Developers integrate their feature branches into this common branch
2. Common branch is regularly rebased onto master to stay current
3. Final merge to master happens after team review and testing

### üìå Branch Details:
- **Base Branch:** \`$base_branch\`
- **Created:** $(date)
- **Initial Commit:** Empty commit for branch establishment

### ‚úÖ Ready for:
- [ ] Feature branch integrations
- [ ] Code reviews
- [ ] Testing and validation
- [ ] Final merge to $base_branch

---
*This PR was automatically created by the git-workflow script*"
    
    # Create the PR
    log_action "Creating PR with GitHub CLI..."
    
    if gh pr create \
        --title "$pr_title" \
        --body "$pr_body" \
        --base "$base_branch" \
        --head "$branch" \
        --draft 2>/dev/null; then
        
        log_success "‚úÖ Pull Request created successfully!"
        
        # Get PR URL
        local pr_url=$(gh pr view --json url --jq .url 2>/dev/null)
        if [ -n "$pr_url" ]; then
            echo -e "${GREEN}üîó PR URL: $pr_url${NC}"
        fi
        
        # Show PR status
        echo ""
        echo -e "${CYAN}üìã PR Status:${NC}"
        echo "  ‚Ä¢ Status: Draft (ready for feature integrations)"
        echo "  ‚Ä¢ Base: $base_branch ‚Üê Head: $branch"
        echo "  ‚Ä¢ Ready for team collaboration"
        
    else
        log_warning "Failed to create PR via GitHub CLI"
        echo ""
        echo -e "${YELLOW}üí° Manual PR Creation Required:${NC}"
        echo "  1. Visit: https://github.com/$(git remote get-url origin | sed 's/.*github.com[:/]\([^.]*\).*/\1/')/compare/$base_branch...$branch"
        echo "  2. Title: $pr_title"
        echo "  3. Mark as Draft initially"
        echo ""
    fi
}

# Enhanced workflow summary with PR information
show_workflow_summary() {
    local common_branch="$1"
    local feature_branch="$2"
    local skip_feature_integration="$3"
    local branch_created="$4"
    
    echo ""
    echo -e "${GREEN}üéâ Workflow completed successfully!${NC}"
    echo -e "${CYAN}===========================================${NC}"
    echo -e "${CYAN}üìä WORKFLOW SUMMARY${NC}"
    echo -e "${CYAN}===========================================${NC}"
    
    if [ "$branch_created" = true ]; then
        echo "‚úÖ Common branch '$common_branch' created from master"
        echo "‚úÖ Empty commit added for branch establishment"
        echo "‚úÖ Pull Request created (draft mode)"
    else
        echo "‚úÖ Common branch '$common_branch' processed"
    fi
    
    if [[ "$skip_feature_integration" == "false" ]] && [ -n "$feature_branch" ]; then
        echo "‚úÖ Changes from '$feature_branch' integrated using rebase/cherry-pick"
    else
        echo "‚úÖ Common branch synced with master (no feature integration)"
    fi
    
    echo "‚úÖ Merged commits cleaned up"
    echo "‚úÖ Common branch rebased onto master (no merge commits)"
    echo "‚úÖ Changes force-pushed to remote with lease protection"
    
    if [ "$branch_created" = true ]; then
        echo ""
        echo -e "${YELLOW}üîÑ Next Steps:${NC}"
        echo "  1. Review the created Pull Request"
        echo "  2. Start integrating feature branches"
        echo "  3. Mark PR as 'Ready for Review' when complete"
        echo "  4. Merge to master after team approval"
    fi
    
    echo -e "${CYAN}===========================================${NC}"
}

# Clean commits that are already merged to master
clean_merged_commits() {
    local common_branch="$1"
    
    log_action "Checking for commits already merged to master"
    
    local unmerged_commits=$(git rev-list --oneline "$common_branch" --not "$MASTER_BRANCH" 2>/dev/null)
    
    if [ -z "$unmerged_commits" ]; then
        log_success "No commits to clean - common branch is in sync with master"
        return 0
    fi
    
    echo "Commits in common branch not yet in master:"
    echo "$unmerged_commits" | sed 's/^/  /'
    
    local merged_commits=$(git cherry -v "$MASTER_BRANCH" "$common_branch" | grep "^-" | cut -d' ' -f2-)
    
    if [ -n "$merged_commits" ]; then
        echo -e "${YELLOW}Found commits that may have been merged to master:${NC}"
        echo "$merged_commits" | sed 's/^/  /'
        
        read -p "Remove merged commits from common branch? (y/N): " remove_merged
        if [[ $remove_merged =~ ^[Yy]$ ]]; then
            log_action "Cleaning merged commits"
            execute_copilot "rebase $common_branch onto $MASTER_BRANCH interactively to remove merged commits"
        fi
    fi
}

# Cherry-pick missing commits from feature branch
cherry_pick_missing_commits() {
    local common_branch="$1"
    local feature_branch="$2"
    
    log_action "Checking for missing commits from feature branch '$feature_branch'"
    
    local missing_commits=$(get_unique_commits "$feature_branch" "$common_branch")
    
    if [ -z "$missing_commits" ]; then
        log_success "All commits from '$feature_branch' are already in '$common_branch'"
        return 0
    fi
    
    echo -e "${YELLOW}Missing commits from '$feature_branch':${NC}"
    echo "$missing_commits" | sed 's/^/  /'
    
    read -p "Cherry-pick these commits to common branch? (Y/n): " do_cherry_pick
    if [[ ! $do_cherry_pick =~ ^[Nn]$ ]]; then
        log_action "Cherry-picking missing commits"
        
        local commit_hashes=$(echo "$missing_commits" | cut -d' ' -f1 | tac)
        
        for commit in $commit_hashes; do
            log_action "Cherry-picking commit: $commit"
            if ! execute_git "git cherry-pick $commit" "Cherry-picking $commit"; then
                log_error "Cherry-pick failed for commit $commit"
                log_warning "Please resolve conflicts and continue"
                
                read -p "Press Enter after resolving conflicts..."
                execute_git "git add . && git cherry-pick --continue" "Continuing cherry-pick"
            fi
        done
        
        log_success "Cherry-pick completed successfully"
        return 0
    else
        log_warning "Skipping cherry-pick as requested"
        return 0
    fi
}

# Resolve conflicts intelligently
resolve_conflicts() {
    local common_branch="$1"
    local feature_branch="$2"
    
    log_error "Merge conflicts detected!"
    echo -e "${YELLOW}Conflict resolution strategy:${NC}"
    echo "1. Preserve all developer changes in common branch"
    echo "2. Integrate new changes from feature branch"
    echo "3. Remove any changes already merged to master"
    
    read -p "Shall I help resolve conflicts? (Y/n): " resolve_conflicts
    if [[ ! $resolve_conflicts =~ ^[Nn]$ ]]; then
        log_action "Starting intelligent conflict resolution"
        
        echo -e "${CYAN}Files with conflicts:${NC}"
        git status --porcelain | grep "^UU\|^AA\|^DD" | sed 's/^../  /'
        
        execute_copilot "resolve merge conflicts preserving all developer changes from $common_branch while integrating new changes from $feature_branch"
        
        echo ""
        echo -e "${YELLOW}üí° Conflict Resolution Steps:${NC}"
        echo "1. Edit each conflicted file manually"
        echo "2. Keep ALL existing changes from other developers"
        echo "3. Integrate your new changes appropriately"
        echo "4. Remove any duplicate functionality already in master"
        echo "5. Test the combined changes"
        
        read -p "Press Enter after resolving all conflicts manually..."
        
        execute_copilot "add all resolved conflict files and complete the merge"
        
        return 0
    else
        log_error "Conflict resolution cancelled"
        return 1
    fi
}

# Show detailed help
show_detailed_help() {
    echo -e "${BLUE}üîß Git Workflow Script - Help${NC}"
    echo "============================="
    echo ""
    echo -e "${YELLOW}USAGE:${NC}"
    echo "  ./git-workflow.sh [mode] [parameters...]"
    echo ""
    echo -e "${YELLOW}MODES:${NC}"
    echo "  Workflow Mode:"
    echo "    ./git-workflow.sh <common-branch> [feature-branch]"
    echo "    Example: ./git-workflow.sh dev-common feature-auth"
    echo ""
    echo "  AI Command Mode:"
    echo "    ./git-workflow.sh git-mode"
    echo "    ./git-workflow.sh ai"
    echo "    ./git-workflow.sh interactive"
    echo ""
    echo "  Show Menu:"
    echo "    ./git-workflow.sh"
    echo "    ./git-workflow.sh menu"
    echo ""
    echo -e "${YELLOW}WORKFLOW MODE:${NC}"
    echo "  Automates common branch management with conflict resolution"
    echo "  - Syncs common branch with master using rebase"
    echo "  - Integrates feature branch changes via cherry-pick or rebase"
    echo "  - Automatically resolves version conflicts in pom.xml files"
    echo "  - Handles multi-step rebase conflicts automatically"
    echo ""
    echo -e "${YELLOW}AI COMMAND MODE:${NC}"
    echo "  Interactive git assistant powered by GitHub Copilot"
    echo "  - Natural language git commands"
    echo "  - Automatic placeholder resolution"
    echo "  - Smart error handling and suggestions"
    echo ""
    echo -e "${YELLOW}OPTIONS:${NC}"
    echo "  --help, -h, help    Show this help"
    echo "  --version, -v       Show version info"
}

# Show version info
show_version() {
    echo -e "${BLUE}Git Workflow Script${NC}"
    echo "Version: 2.0.0"
    echo "Features: AI-powered conflict resolution, placeholder handling"
    echo "Dependencies: git, gh (GitHub CLI)"
}

# Handle main menu
handle_main_menu() {
    echo -e "${BLUE}üîß Git Workflow Assistant${NC}"
    echo "========================="
    echo ""
    echo "Choose a mode:"
    echo ""
    echo -e "${CYAN}1) Workflow Mode${NC} - Automated branch management"
    echo "   ‚Ä¢ Sync common branch with master"
    echo "   ‚Ä¢ Integrate feature branch changes"
    echo "   ‚Ä¢ Automatic conflict resolution"
    echo ""
    echo -e "${CYAN}2) AI Command Mode${NC} - Interactive git assistant"
    echo "   ‚Ä¢ Natural language git commands"
    echo "   ‚Ä¢ GitHub Copilot integration"
    echo "   ‚Ä¢ Smart command suggestions"
    echo ""
    echo -e "${CYAN}3) Help${NC} - Show detailed documentation"
    echo ""
    echo -e "${CYAN}4) Exit${NC} - Quit the script"
    echo ""
    read -p "Select mode (1-4): " choice
    
    case "$choice" in
        1)
            echo ""
            read -p "Enter common branch name: " common_branch
            if [ -n "$common_branch" ]; then
                read -p "Enter feature branch name (optional): " feature_branch
                check_git_repo
                main_workflow "$common_branch" "$feature_branch"
            else
                log_error "Common branch name is required"
                exit 1
            fi
            ;;
        2)
            check_git_repo
            git_command_mode
            ;;
        3)
            show_detailed_help
            ;;
        4)
            echo -e "${GREEN}üëã Goodbye!${NC}"
            exit 0
            ;;
        *)
            log_error "Invalid choice. Please select 1-4."
            exit 1
            ;;
    esac
}

# Main workflow function with enhanced error handling
main_workflow() {
    local common_branch="$1"
    local feature_branch="$2"
    
    echo -e "${BLUE}üöÄ Starting Intelligent Common Branch Workflow${NC}"
    echo "=============================================="
    echo "Common branch: $common_branch"
    echo "Master branch: $MASTER_BRANCH"
    echo ""
    
    # Handle feature branch parameter
    local skip_feature_integration=false
    if [ -z "$feature_branch" ]; then
        log_warning "No feature branch specified"
        echo "Available feature branches:"
        git branch | grep -v -E "(master|main|$common_branch)" | sed 's/^[ *]*/  - /'
        echo ""
        read -p "Enter feature branch name to integrate (or press Enter to skip): " feature_branch
        
        if [ -z "$feature_branch" ]; then
            log_warning "Skipping feature branch integration - will only sync common branch"
            skip_feature_integration=true
        fi
    fi
    
    if [[ "$skip_feature_integration" == "false" ]]; then
        echo "Feature branch: $feature_branch"
        
        # Validate feature branch
        if [[ "$feature_branch" == "$MASTER_BRANCH" ]] || [[ "$feature_branch" == "$common_branch" ]]; then
            log_error "Cannot use $feature_branch as feature branch"
            exit 1
        fi
        
        # Check if feature branch exists
        if ! branch_exists_locally "$feature_branch" && ! branch_exists_remotely "$feature_branch"; then
            log_error "Feature branch '$feature_branch' does not exist"
            exit 1
        fi
    else
        echo "Mode: Common branch sync only (no feature integration)"
    fi
    
    echo ""
    
    # Step 1: Check if common branch exists
    log_step "1" "Checking Common Branch '$common_branch'"
    if branch_exists_locally "$common_branch"; then
        log_success "Common branch '$common_branch' exists locally"
    elif branch_exists_remotely "$common_branch"; then
        log_warning "Common branch exists on remote, creating local tracking branch"
        execute_copilot "checkout new local branch $common_branch tracking origin/$common_branch"
    else
        log_warning "Common branch '$common_branch' does not exist"
        read -p "Create common branch '$common_branch'? (Y/n): " create_branch
        if [[ ! $create_branch =~ ^[Nn]$ ]]; then
            create_common_branch "$common_branch"
        else
            log_error "Cannot proceed without common branch"
            exit 1
        fi
    fi
    
    # Step 2: Switch to common branch and update
    log_step "2" "Switching to Common Branch and Updating"
    execute_copilot "checkout to $common_branch branch"
    sleep 1
    execute_copilot "pull latest changes from origin $common_branch branch"
    
    # Step 3: Clean merged commits
    log_step "3" "Cleaning Commits Already Merged to Master"
    clean_merged_commits "$common_branch"
    
    # Step 4: Feature branch integration (conditional)
    if [[ "$skip_feature_integration" == "false" ]]; then
        log_step "4" "Integrating Feature Branch '$feature_branch'"
        
        log_action "Testing for conflicts with feature branch '$feature_branch'"
        
        # Create a temporary merge to test for conflicts
        git merge --no-commit --no-ff "$feature_branch" 2>/dev/null
        
        if has_conflicts; then
            log_warning "Conflicts detected between '$common_branch' and '$feature_branch'"
            
            # Abort the test merge
            execute_git "git merge --abort" "Aborting test merge"
            
            # Resolve conflicts
            if resolve_conflicts "$common_branch" "$feature_branch"; then
                log_action "Rebasing feature branch changes onto common branch"
                execute_copilot "rebase $feature_branch onto current branch"
            else
                log_error "Workflow stopped due to unresolved conflicts"
                exit 1
            fi
        else
            # No conflicts - abort test merge and do cherry-pick instead
            execute_git "git merge --abort 2>/dev/null || true" "Cleaning up test merge"
            
            log_success "No conflicts detected"
            
            # Cherry-pick missing commits
            log_action "Adding missing commits from feature branch using cherry-pick"
            cherry_pick_missing_commits "$common_branch" "$feature_branch"
        fi
        
        step_number="5"
    else
        log_step "4" "Skipping Feature Integration (No feature branch specified)"
        step_number="4"
    fi
    
    # Step 5/4: Sync common branch with master using rebase
    log_step "$step_number" "Syncing Common Branch with Master (Rebase)"
    log_action "Rebasing common branch onto master to avoid merge commits"
    
    # Fetch latest master
    if ! execute_git "git fetch origin $MASTER_BRANCH" "Fetching latest master"; then
        log_error "Failed to fetch master branch"
        exit 1
    fi
    
    # Get current branch for rebase command
    local current_branch=$(git branch --show-current)
    
    # Rebase common branch onto master with proper branch resolution
    log_action "Starting rebase onto origin/$MASTER_BRANCH"
    
    # Create a more specific command that doesn't use placeholders
    local rebase_cmd="git rebase origin/$MASTER_BRANCH"
    
    echo -e "${GREEN}üöÄ EXECUTING: $rebase_cmd${NC}"
    eval "$rebase_cmd"
    local rebase_exit_code=$?
    
    # Check if rebase succeeded or had conflicts
    if [ $rebase_exit_code -eq 0 ]; then
        log_success "Rebase completed successfully"
    else
        # Rebase failed - check if it's due to conflicts
        if has_conflicts; then
            log_warning "ü§ñ CONFLICTS DETECTED - Starting automatic multi-step resolution..."
            
            # Handle multi-step rebase with automatic conflict resolution
            local max_attempts=10
            local attempt=1
            local all_resolved=true
            
            while [ $attempt -le $max_attempts ]; do
                if has_conflicts; then
                    log_action "üîÑ Step $attempt: Resolving conflicts in rebase..."
                    
                    # Show which files have conflicts
                    echo -e "${CYAN}Conflicted files in step $attempt:${NC}"
                    get_conflicted_files | sed 's/^/  /'
                    
                    # Automatically resolve conflicts
                    if resolve_conflicts_automatically; then
                        log_success "‚úÖ Step $attempt: All conflicts resolved automatically"
                        
                        # Continue the rebase
                        log_action "üîÑ Step $attempt: Continuing rebase..."
                        git rebase --continue
                        local continue_exit_code=$?
                        
                        if [ $continue_exit_code -eq 0 ]; then
                            # Check if rebase is completely done
                            if git status | grep -q "rebase in progress"; then
                                log_success "‚úÖ Step $attempt: Rebase step completed, checking for more conflicts..."
                                ((attempt++))
                                sleep 1  # Small delay to let git settle
                            else
                                log_success "üéâ REBASE COMPLETED SUCCESSFULLY after $attempt steps!"
                                break
                            fi
                        else
                            # Continue failed, check if we have new conflicts
                            if has_conflicts; then
                                log_action "üîÑ Step $attempt: New conflicts detected after continue, proceeding to next iteration..."
                                ((attempt++))
                            else
                                # Continue failed for other reason
                                log_error "‚ùå Step $attempt: Rebase continue failed (exit code: $continue_exit_code)"
                                all_resolved=false
                                break
                            fi
                        fi
                    else
                        log_error "‚ùå Step $attempt: Could not auto-resolve conflicts"
                        all_resolved=false
                        break
                    fi
                else
                    # No more conflicts
                    if git status | grep -q "rebase in progress"; then
                        log_action "üîÑ Step $attempt: No conflicts, but rebase still in progress..."
                        git rebase --continue
                        if [ $? -eq 0 ]; then
                            if ! git status | grep -q "rebase in progress"; then
                                log_success "üéâ REBASE COMPLETED SUCCESSFULLY!"
                                break
                            fi
                        fi
                        ((attempt++))
                    else
                        log_success "üéâ REBASE COMPLETED SUCCESSFULLY!"
                        break
                    fi
                fi
                
                # Safety check
                if [ $attempt -gt $max_attempts ]; then
                    log_error "‚ùå Maximum rebase attempts ($max_attempts) reached"
                    all_resolved=false
                    break
                fi
            done
            
            # Final status check
            if [ "$all_resolved" = false ] || has_conflicts; then
                log_error "‚ùå Automatic conflict resolution failed after $attempt attempts"
                echo ""
                echo -e "${YELLOW}üîß MANUAL INTERVENTION REQUIRED:${NC}"
                echo "Current rebase status:"
                git status --porcelain
                echo ""
                if has_conflicts; then
                    echo -e "${CYAN}Remaining conflicted files:${NC}"
                    get_conflicted_files | sed 's/^/  /'
                    echo ""
                    echo "Manual resolution steps:"
                    echo "1. Edit conflicted files to resolve conflicts"
                    echo "2. Stage resolved files: git add <files>"
                    echo "3. Continue: git rebase --continue"
                    echo "4. Repeat until rebase completes"
                fi
                echo "5. Or abort: git rebase --abort"
                echo ""
                echo -e "${RED}‚ùå STOPPING WORKFLOW${NC}"
                exit 1
            else
                log_success "üéâ ALL REBASE STEPS COMPLETED SUCCESSFULLY!"
            fi
        else
            log_error "Rebase failed for unknown reason (exit code: $rebase_exit_code)"
            echo -e "${RED}‚ùå STOPPING WORKFLOW${NC}"
            exit 1
        fi
    fi
    
    # Step 6/5: Push changes
    ((step_number++))
    log_step "$step_number" "Pushing Changes to Remote"
    execute_copilot "force push current branch to origin safely with lease protection"
    
    echo ""
    echo -e "${GREEN}üéâ Workflow completed successfully!${NC}"
    echo -e "${CYAN}===========================================${NC}"
    echo -e "${CYAN}üìä WORKFLOW SUMMARY${NC}"
    echo -e "${CYAN}===========================================${NC}"
    echo "‚úÖ Common branch '$common_branch' processed"
    if [[ "$skip_feature_integration" == "false" ]]; then
        echo "‚úÖ Changes from '$feature_branch' integrated using rebase/cherry-pick"
    else
        echo "‚úÖ Common branch synced with master (no feature integration)"
    fi
    echo "‚úÖ Merged commits cleaned up"
    echo "‚úÖ Common branch rebased onto master (no merge commits)"
    echo "‚úÖ Changes force-pushed to remote with lease protection"
    echo -e "${CYAN}===========================================${NC}"
}

# Interactive Git Command Mode - AI-powered git assistant
git_command_mode() {
    echo -e "${BLUE}ü§ñ AI-Powered Git Command Mode${NC}"
    echo "================================="
    echo "Enter any git operation in natural language, and I'll execute it!"
    echo "Examples:"
    echo "  ‚Ä¢ 'show me the last 5 commits'"
    echo "  ‚Ä¢ 'create a new branch called feature-auth'"
    echo "  ‚Ä¢ 'merge develop branch into current branch'"
    echo "  ‚Ä¢ 'undo the last commit but keep changes'"
    echo "  ‚Ä¢ 'push all my changes to origin'"
    echo "  ‚Ä¢ 'show what files have changed'"
    echo "  ‚Ä¢ 'stash my current changes'"
    echo "  ‚Ä¢ 'compare my branch with master'"
    echo ""
    echo "Type 'exit' to return to main menu, 'help' for more examples"
    echo "==============================================="
    echo ""
    
    while true; do
        echo -e "${CYAN}Current branch: $(git branch --show-current)${NC}"
        echo -e "${CYAN}Status: $(git status --porcelain | wc -l) changed files${NC}"
        echo ""
        read -p "ü§ñ Git AI> " user_command
        
        # Handle special commands
        case "$user_command" in
            "exit"|"quit"|"q")
                log_success "Exiting Git Command Mode"
                break
                ;;
            "help"|"h")
                show_git_command_help
                continue
                ;;
            "status"|"s")
                git status
                continue
                ;;
            "")
                continue
                ;;
            *)
                # Process natural language git command
                process_natural_language_git_command "$user_command"
                ;;
        esac
        
        echo ""
    done
}

# Show help for git command mode
show_git_command_help() {
    echo -e "${BLUE}ü§ñ Git AI Command Examples${NC}"
    echo "=========================="
    echo ""
    echo -e "${YELLOW}Branch Operations:${NC}"
    echo "  ‚Ä¢ 'create branch feature-login from master'"
    echo "  ‚Ä¢ 'switch to develop branch'"
    echo "  ‚Ä¢ 'delete branch feature-old'"
    echo "  ‚Ä¢ 'list all branches'"
    echo "  ‚Ä¢ 'show remote branches'"
    echo ""
    echo -e "${YELLOW}Commit Operations:${NC}"
    echo "  ‚Ä¢ 'commit all changes with message \"add new feature\"'"
    echo "  ‚Ä¢ 'commit only modified files'"
    echo "  ‚Ä¢ 'undo last commit but keep changes'"
    echo "  ‚Ä¢ 'undo last commit completely'"
    echo "  ‚Ä¢ 'change last commit message'"
    echo ""
    echo -e "${YELLOW}Remote Operations:${NC}"
    echo "  ‚Ä¢ 'push current branch to origin'"
    echo "  ‚Ä¢ 'pull latest changes from master'"
    echo "  ‚Ä¢ 'fetch all remote changes'"
    echo "  ‚Ä¢ 'push and set upstream'"
    echo ""
    echo -e "${YELLOW}History & Information:${NC}"
    echo "  ‚Ä¢ 'show last 10 commits'"
    echo "  ‚Ä¢ 'show commit history with graph'"
    echo "  ‚Ä¢ 'show what changed in last commit'"
    echo "  ‚Ä¢ 'show diff between my branch and master'"
    echo "  ‚Ä¢ 'who last modified this file: src/app.js'"
    echo ""
    echo -e "${YELLOW}Stashing & Cleanup:${NC}"
    echo "  ‚Ä¢ 'stash all my changes'"
    echo "  ‚Ä¢ 'apply last stash'"
    echo "  ‚Ä¢ 'clean untracked files'"
    echo "  ‚Ä¢ 'reset hard to last commit'"
    echo ""
    echo -e "${YELLOW}Merging & Rebasing:${NC}"
    echo "  ‚Ä¢ 'merge feature-auth into current branch'"
    echo "  ‚Ä¢ 'rebase current branch onto master'"
    echo "  ‚Ä¢ 'cherry pick commit abc123'"
    echo "  ‚Ä¢ 'resolve merge conflicts'"
    echo ""
    echo -e "${YELLOW}Advanced Operations:${NC}"
    echo "  ‚Ä¢ 'squash last 3 commits'"
    echo "  ‚Ä¢ 'create a tag version 1.0'"
    echo "  ‚Ä¢ 'find commits that changed login.js'"
    echo "  ‚Ä¢ 'show blame for src/app.js'"
    echo ""
}

# Process natural language git commands using LLM
process_natural_language_git_command() {
    local user_input="$1"
    
    log_action "Processing: \"$user_input\""
    
    # Use the EXACT same working pattern as the workflow mode
    local temp_file="/tmp/git_cmd"
    local simple_prompt="$user_input"
    
    echo -e "${BLUE}ü§ñ Asking Copilot for command...${NC}"
    
    # Use the exact working pattern from workflow mode
    gh copilot suggest -t git -s "$temp_file" "$simple_prompt"
    local copilot_exit_code=$?
    
    if [ $copilot_exit_code -ne 0 ]; then
        log_warning "Copilot failed, trying pattern matching..."
        handle_common_git_patterns "$user_input"
        return
    fi
    
    # Check if command was generated
    if [ -f "$temp_file" ] && [ -s "$temp_file" ]; then
        local suggested_cmd=$(cat "$temp_file")
        echo -e "${GREEN}ü§ñ AI Suggestion: $suggested_cmd${NC}"
        
        # Ask for confirmation before executing
        read -p "Execute this command? (Y/n/edit): " confirm
        
        case "$confirm" in
            [Nn])
                log_warning "Command cancelled by user"
                ;;
            [Ee]*)
                read -p "Enter modified command: " modified_cmd
                if [ -n "$modified_cmd" ]; then
                    execute_user_git_command "$modified_cmd"
                fi
                ;;
            *)
                # Execute using the same pattern as workflow mode
                execute_user_git_command "$suggested_cmd"
                ;;
        esac
        
        # Clean up
        rm -f "$temp_file"
        return 0
    else
        # Fallback to pattern matching if file generation failed
        log_warning "AI command generation failed, trying pattern matching..."
        handle_common_git_patterns "$user_input"
    fi
    
    rm -f "$temp_file"
}

# Enhanced execute function that handles templates
execute_user_git_command() {
    local original_cmd="$1"
    
    # Check for placeholder patterns before execution
    if [[ "$original_cmd" =~ \<.*\> ]]; then
        log_action "Resolving command placeholders..."
        local final_cmd=$(resolve_command_placeholders "$original_cmd")
        if [ $? -ne 0 ]; then
            log_error "Command processing failed"
            return 1
        fi
    else
        local final_cmd="$original_cmd"
    fi
    
    echo -e "${GREEN}üöÄ EXECUTING: $final_cmd${NC}"
    
    # Safety check for destructive commands
    if [[ "$final_cmd" =~ (rm|delete|reset.*--hard|clean.*-f|force) ]]; then
        echo -e "${RED}‚ö†Ô∏è  WARNING: This is a potentially destructive command!${NC}"
        read -p "Are you sure you want to proceed? (yes/NO): " safety_confirm
        if [[ "$safety_confirm" != "yes" ]]; then
            log_warning "Destructive command cancelled for safety"
            return 1
        fi
    fi
    
    # Execute the command
    eval "$final_cmd"
    local exit_code=$?
    
    if [ $exit_code -eq 0 ]; then
        log_success "Command executed successfully"
        show_post_command_status "$final_cmd"
    else
        log_error "Command failed with exit code $exit_code"
        show_error_troubleshooting "$final_cmd" "$exit_code"
    fi
    
    return $exit_code
}

# Show relevant status information after command execution
show_post_command_status() {
    local cmd="$1"
    
    # Show appropriate status based on command type
    if [[ "$cmd" =~ (checkout|switch|branch) ]]; then
        echo -e "${CYAN}üìç Current branch: $(git branch --show-current)${NC}"
    elif [[ "$cmd" =~ (commit|add|reset) ]]; then
        echo -e "${CYAN}üìä Repository status:${NC}"
        git status --short
    elif [[ "$cmd" =~ (push|pull|fetch) ]]; then
        echo -e "${CYAN}üîÑ Remote status updated${NC}"
    elif [[ "$cmd" =~ (log|show) ]]; then
        # Status already shown by the command
        :
    else
        # Show basic status for other commands
        echo -e "${CYAN}üìä Files changed: $(git status --porcelain | wc -l)${NC}"
    fi
}

# Handle common git patterns when LLM is unavailable
handle_common_git_patterns() {
    local input="$1"
    local cmd=""
    
    echo -e "${BLUE}üîç Pattern matching for: \"$input\"${NC}"
    
    # Convert common patterns to git commands
    case "$(echo "$input" | tr '[:upper:]' '[:lower:]')" in
        *"rebase"*"master"*|*"rebase"*"main"*)
            cmd="git rebase origin/master"
            ;;
        *"rebase"*"origin"*)
            cmd="git rebase origin/$(git branch --show-current)"
            ;;
        *"rebase"*|*"rebase onto"*)
            echo "Available branches:"
            git branch -a | head -10
            read -p "Enter branch to rebase onto (default: origin/master): " rebase_target
            rebase_target="${rebase_target:-origin/master}"
            cmd="git rebase $rebase_target"
            ;;
        *"last"*"commit"*|*"recent"*"commit"*)
            cmd="git log -1 --oneline"
            ;;
        *"last"*[0-9]*"commit"*)
            local num=$(echo "$input" | grep -o '[0-9]\+' | head -1)
            cmd="git log -${num:-5} --oneline"
            ;;
        *"status"*|*"what changed"*|*"show changes"*)
            cmd="git status"
            ;;
        *"push"*"origin"*|*"push"*"current"*)
            cmd="git push origin $(git branch --show-current)"
            ;;
        *"push"*"upstream"*|*"push"*"set"*"upstream"*)
            cmd="git push -u origin $(git branch --show-current)"
            ;;
        *"pull"*"latest"*|*"pull"*"master"*|*"pull"*"main"*)
            cmd="git pull origin master"
            ;;
        *"pull"*|*"update"*)
            cmd="git pull origin $(git branch --show-current)"
            ;;
        *"branch"*"list"*|*"show"*"branch"*|*"all"*"branch"*)
            cmd="git branch -a"
            ;;
        *"create"*"branch"*)
            read -p "Enter new branch name: " branch_name
            if [ -n "$branch_name" ]; then
                cmd="git checkout -b $branch_name"
            fi
            ;;
        *"switch"*"to"*|*"checkout"*)
            local branch=$(echo "$input" | sed -n 's/.*\(switch to\|checkout\) \([a-zA-Z0-9_-]\+\).*/\2/p')
            if [ -n "$branch" ]; then
                cmd="git checkout $branch"
            else
                read -p "Enter branch name to switch to: " branch_name
                if [ -n "$branch_name" ]; then
                    cmd="git checkout $branch_name"
                fi
            fi
            ;;
        *"commit"*"all"*|*"commit"*"everything"*)
            read -p "Enter commit message: " commit_msg
            if [ -n "$commit_msg" ]; then
                cmd="git add . && git commit -m \"$commit_msg\""
            fi
            ;;
        *"stash"*"save"*|*"stash"*"changes"*|*"stash"*)
            cmd="git stash"
            ;;
        *"stash"*"pop"*|*"apply"*"stash"*)
            cmd="git stash pop"
            ;;
        *"undo"*"last"*"commit"*|*"revert"*"last"*)
            cmd="git reset --soft HEAD~1"
            ;;
        *"diff"*"master"*|*"compare"*"master"*)
            cmd="git diff master..HEAD"
            ;;
        *"diff"*|*"what"*"change"*)
            cmd="git diff"
            ;;
        *"merge"*)
            local branch=$(echo "$input" | sed -n 's/.*merge \([a-zA-Z0-9_-]\+\).*/\1/p')
            if [ -n "$branch" ]; then
                cmd="git merge $branch"
            else
                read -p "Enter branch name to merge: " branch_name
                if [ -n "$branch_name" ]; then
                    cmd="git merge $branch_name"
                fi
            fi
            ;;
        *"fetch"*|*"update"*"remote"*)
            cmd="git fetch --all"
            ;;
        *)
            echo -e "${RED}‚ùå Could not understand command: \"$input\"${NC}"
            echo ""
            echo -e "${YELLOW}üí° Try one of these patterns:${NC}"
            echo "  ‚Ä¢ 'rebase onto master'"
            echo "  ‚Ä¢ 'show last 5 commits'"
            echo "  ‚Ä¢ 'commit all changes'"
            echo "  ‚Ä¢ 'push to origin'"
            echo "  ‚Ä¢ 'create branch feature-name'"
            echo "  ‚Ä¢ 'switch to branch-name'"
            echo "  ‚Ä¢ 'merge branch-name'"
            echo "  ‚Ä¢ 'stash my changes'"
            echo "  ‚Ä¢ 'show status'"
            return
            ;;
    esac
    
    if [ -n "$cmd" ]; then
        echo -e "${GREEN}üîç Pattern Match: $cmd${NC}"
        read -p "Execute this command? (Y/n): " confirm
        if [[ ! "$confirm" =~ ^[Nn]$ ]]; then
            execute_user_git_command "$cmd"
        fi
    fi
}

# Main script execution
main() {
    local command="$1"
    local branch_or_param="$2"
    local feature_branch="$3"
    
    # Handle different modes
    case "$command" in
        "help"|"--help"|"-h")
            show_detailed_help
            exit 0
            ;;
        "--version"|"-v"|"version")
            show_version
            exit 0
            ;;
        "git-mode"|"ai"|"assistant"|"cmd"|"command"|"interactive")
            check_git_repo
            git_command_mode
            exit 0
            ;;
        "menu"|"main"|"")
            # Show main menu when no parameters or explicit menu request
            handle_main_menu
            exit 0
            ;;
        *)
            # Traditional workflow mode with parameters
            local common_branch="$command"
            local feature_branch="$branch_or_param"
            
            # Validate workflow mode parameters
            if [ -z "$common_branch" ]; then
                # No parameters provided, show main menu
                handle_main_menu
                exit 0
            fi
            
            check_git_repo
            
            # Show workflow mode header
            echo -e "${BLUE}üîß Workflow Mode - Automated Branch Management${NC}"
            echo "=============================================="
            echo "Common branch: $common_branch"
            if [ -n "$feature_branch" ]; then
                echo "Feature branch: $feature_branch"
                echo "Mode: Feature Integration"
            else
                echo "Mode: Sync Only"
            fi
            echo ""
            
            main_workflow "$common_branch" "$feature_branch"
            ;;
    esac
}

# Run the script
main "$@"

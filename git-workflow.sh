#!/bin/bash

# Intelligent Common Branch Workflow
# Usage: ./git-workflow.sh <common-branch-name> [feature-branch-name]

# Self-fix line endings if needed (one-time check)
if [[ "$0" == *"git-workflow.sh"* ]] && [[ ! -f "/tmp/.git-workflow-fixed" ]]; then
    if command -v file >/dev/null 2>&1 && file "$0" | grep -q "CRLF"; then
        echo "üîß Fixing line endings..."
        if command -v sed >/dev/null 2>&1; then
            sed -i '' 's/\r$//' "$0" 2>/dev/null || sed -i 's/\r$//' "$0" 2>/dev/null
            chmod +x "$0"
            touch "/tmp/.git-workflow-fixed"
            echo "‚úÖ Line endings fixed. Re-running script..."
            exec "$0" "$@"
        fi
    fi
fi

# Configuration
MASTER_BRANCH="master"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Logging functions
log_step() {
    local step_number="$1"
    local step_description="$2"
    echo ""
    echo -e "${CYAN}===========================================${NC}"
    echo -e "${CYAN}üìã STEP $step_number: $step_description${NC}"
    echo -e "${CYAN}===========================================${NC}"
}

log_action() {
    local action="$1"
    echo -e "${BLUE}üîß ACTION: $action${NC}"
}

log_success() {
    local message="$1"
    echo -e "${GREEN}‚úÖ SUCCESS: $message${NC}"
}

log_warning() {
    local message="$1"
    echo -e "${YELLOW}‚ö†Ô∏è  WARNING: $message${NC}"
}

log_error() {
    local message="$1"
    echo -e "${RED}‚ùå ERROR: $message${NC}"
}

# Enhanced execute Copilot command with proper branch name resolution
execute_copilot() {
    local description="$1"
    local temp_file="/tmp/git_cmd"
    
    log_action "Asking Copilot: $description"
    
    # Check if GitHub CLI is available
    if ! command -v gh >/dev/null 2>&1; then
        log_warning "GitHub CLI (gh) not found. Using fallback git commands."
        execute_fallback_command "$description"
        return $?
    fi
    
    # Use the exact working pattern you discovered
    gh copilot suggest -t git -s "$temp_file" "$description"
    local copilot_exit_code=$?
    
    # Check if user exited Copilot
    if [ $copilot_exit_code -ne 0 ]; then
        log_error "Copilot command cancelled or failed"
        echo -e "${RED}‚ùå WORKFLOW STOPPED - User cancelled or Copilot failed${NC}"
        rm -f "$temp_file"
        exit 1
    fi
    
    # Check if command was generated
    if [ -f "$temp_file" ] && [ -s "$temp_file" ]; then
        local cmd=$(cat "$temp_file")
        echo -e "${GREEN}üöÄ EXECUTING: $cmd${NC}"
        
        # Check for placeholder patterns and resolve them
        if [[ "$cmd" =~ \<.*\> ]]; then
            cmd=$(resolve_command_placeholders "$cmd")
            if [ $? -ne 0 ]; then
                log_error "Failed to resolve command placeholders"
                rm -f "$temp_file"
                return 1
            fi
            echo -e "${GREEN}üîß RESOLVED: $cmd${NC}"
        fi
        
        # Execute the resolved command
        eval "$cmd"
        local exit_code=$?
        
        if [ $exit_code -eq 0 ]; then
            log_success "Command executed successfully"
        else
            log_error "Command failed with exit code $exit_code"
            show_error_troubleshooting "$cmd" "$exit_code"
            rm -f "$temp_file"
            exit 1
        fi
        
        # Clean up
        rm -f "$temp_file"
        return $exit_code
    else
        log_warning "No command generated by Copilot"
        echo -e "${RED}‚ùå WORKFLOW STOPPED - No command to execute${NC}"
        rm -f "$temp_file"
        exit 1
    fi
}

# Fallback command execution when GitHub CLI is not available
execute_fallback_command() {
    local description="$1"
    
    log_action "Using fallback git command for: $description"
    
    # Map common descriptions to git commands
    local cmd=""
    case "$description" in
        *"checkout"*"branch"*)
            local branch=$(echo "$description" | grep -o '[a-zA-Z0-9_-]\+' | tail -1)
            cmd="git checkout $branch"
            ;;
        *"pull"*"latest"*)
            cmd="git pull origin $(git branch --show-current)"
            ;;
        *"create"*"branch"*)
            local branch=$(echo "$description" | grep -o '[a-zA-Z0-9_-]\+' | tail -1)
            cmd="git checkout -b $branch"
            ;;
        *"push"*"origin"*)
            cmd="git push origin $(git branch --show-current)"
            ;;
        *"rebase"*)
            cmd="git rebase origin/master"
            ;;
        *)
            log_warning "No fallback available for: $description"
            read -p "Enter git command manually: " cmd
            ;;
    esac
    
    if [ -n "$cmd" ]; then
        execute_git "$cmd" "$description"
    fi
}

# Function to resolve command placeholders
resolve_command_placeholders() {
    local cmd="$1"
    local resolved_cmd="$cmd"
    
    # Get current branch for reference
    local current_branch=$(git branch --show-current 2>/dev/null)
    
    # Resolve common placeholders
    if [[ "$resolved_cmd" =~ \<branch-name\>|\<target-branch\>|\<upstream-branch\> ]]; then
        # Try to determine appropriate branch from context
        if [[ "$resolved_cmd" =~ "origin/" ]]; then
            # For origin operations, use current branch
            resolved_cmd=$(echo "$resolved_cmd" | sed "s/<[^>]*branch[^>]*>/$current_branch/g")
        else
            # For local operations, prompt user
            echo "Available branches:"
            git branch -a | head -10
            read -p "Enter branch name (default: $current_branch): " branch_name
            branch_name="${branch_name:-$current_branch}"
            resolved_cmd=$(echo "$resolved_cmd" | sed "s/<[^>]*branch[^>]*>/$branch_name/g")
        fi
    fi
    
    if [[ "$resolved_cmd" =~ \<commit\>|\<commit-hash\> ]]; then
        echo "Recent commits:"
        git log --oneline -5
        read -p "Enter commit hash: " commit_hash
        if [ -n "$commit_hash" ]; then
            resolved_cmd=$(echo "$resolved_cmd" | sed "s/<[^>]*commit[^>]*>/$commit_hash/g")
        else
            echo "No commit hash provided"
            return 1
        fi
    fi
    
    if [[ "$resolved_cmd" =~ \<message\>|\<commit-message\> ]]; then
        read -p "Enter commit message: " commit_msg
        if [ -n "$commit_msg" ]; then
            resolved_cmd=$(echo "$resolved_cmd" | sed "s/<[^>]*message[^>]*>/\"$commit_msg\"/g")
        else
            echo "No commit message provided"
            return 1
        fi
    fi
    
    if [[ "$resolved_cmd" =~ \<file\>|\<filename\> ]]; then
        echo "Modified files:"
        git status --porcelain
        read -p "Enter filename: " filename
        if [ -n "$filename" ]; then
            resolved_cmd=$(echo "$resolved_cmd" | sed "s/<[^>]*file[^>]*>/$filename/g")
        else
            echo "No filename provided"
            return 1
        fi
    fi
    
    # Check if any placeholders remain
    if [[ "$resolved_cmd" =~ \<.*\> ]]; then
        echo -e "${RED}‚ùå Unresolved placeholders remain in: $resolved_cmd${NC}"
        read -p "Enter the complete command manually: " manual_cmd
        if [ -n "$manual_cmd" ]; then
            resolved_cmd="$manual_cmd"
        else
            return 1
        fi
    fi
    
    echo "$resolved_cmd"
    return 0
}

# Show error troubleshooting based on command type and exit code
show_error_troubleshooting() {
    local cmd="$1"
    local exit_code="$2"
    
    echo ""
    echo -e "${YELLOW}**üí° Troubleshooting suggestions:**${NC}"
    
    if [[ "$cmd" =~ "merge" ]] && [ "$exit_code" -eq 1 ]; then
        echo "  ‚Ä¢ There might be merge conflicts. Try: 'show merge conflicts'"
        echo "  ‚Ä¢ You might need to commit changes first"
    elif [[ "$cmd" =~ "rebase" ]] && [ "$exit_code" -eq 1 ]; then
        echo "  ‚Ä¢ There might be rebase conflicts that need resolution"
        echo "  ‚Ä¢ You might need to commit or stash changes first"
        echo "  ‚Ä¢ The target branch might not exist or be accessible"
    elif [[ "$cmd" =~ "push" ]] && [ "$exit_code" -eq 1 ]; then
        echo "  ‚Ä¢ Remote branch might not exist. Try: 'push and set upstream'"
        echo "  ‚Ä¢ You might need to pull first. Try: 'pull latest changes'"
        echo "  ‚Ä¢ Branch might be protected or you lack permissions"
    elif [[ "$cmd" =~ "checkout|switch" ]] && [ "$exit_code" -eq 1 ]; then
        echo "  ‚Ä¢ Branch might not exist locally or remotely"
        echo "  ‚Ä¢ You might have uncommitted changes. Try: 'stash changes first'"
    elif [[ "$cmd" =~ "pull|fetch" ]] && [ "$exit_code" -eq 1 ]; then
        echo "  ‚Ä¢ Remote repository might be unreachable"
        echo "  ‚Ä¢ Branch might not exist on remote"
        echo "  ‚Ä¢ Network connectivity issues"
    else
        echo "  ‚Ä¢ Check repository status: git status"
        echo "  ‚Ä¢ Verify you're in a git repository"
        echo "  ‚Ä¢ Check if remote is configured: git remote -v"
    fi
}

# Execute git command directly with better error handling
execute_git() {
    local cmd="$1"
    local description="$2"
    
    if [ -n "$description" ]; then
        log_action "$description"
    fi
    
    echo -e "${GREEN}üöÄ EXECUTING: $cmd${NC}"
    
    # Check for placeholder patterns before execution
    if [[ "$cmd" =~ \<.*\> ]]; then
        log_error "Command contains unresolved placeholders: $cmd"
        local resolved_cmd=$(resolve_command_placeholders "$cmd")
        if [ $? -eq 0 ]; then
            cmd="$resolved_cmd"
            echo -e "${GREEN}üîß RESOLVED: $cmd${NC}"
        else
            log_error "Failed to resolve placeholders"
            return 1
        fi
    fi
    
    eval "$cmd"
    local exit_code=$?
    
    if [ $exit_code -eq 0 ]; then
        log_success "Command completed successfully"
    else
        log_error "Command failed with exit code $exit_code"
        show_error_troubleshooting "$cmd" "$exit_code"
    fi
    
    return $exit_code
}

# Check if we're in a git repository
check_git_repo() {
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        log_error "Not in a git repository!"
        exit 1
    fi
}

# Check if branch exists locally
branch_exists_locally() {
    local branch="$1"
    git show-ref --verify --quiet refs/heads/"$branch" 2>/dev/null
}

# Check if branch exists on remote
branch_exists_remotely() {
    local branch="$1"
    git show-ref --verify --quiet refs/remotes/origin/"$branch" 2>/dev/null
}

# Get commits that are unique to a branch
get_unique_commits() {
    local source_branch="$1"
    local target_branch="$2"
    git rev-list --oneline "$target_branch..$source_branch" 2>/dev/null
}

# Check for merge conflicts
has_conflicts() {
    git status --porcelain | grep -q "^UU\|^AA\|^DD"
}

# Get list of conflicted files
get_conflicted_files() {
    git status --porcelain | grep "^UU\|^AA\|^DD" | sed 's/^..//'
}

# Show detailed help
show_detailed_help() {
    echo -e "${BLUE}üîß Git Workflow Script - Help${NC}"
    echo "============================="
    echo ""
    echo -e "${YELLOW}USAGE:${NC}"
    echo "  ./git-workflow.sh [mode] [parameters...]"
    echo ""
    echo -e "${YELLOW}MODES:${NC}"
    echo "  Workflow Mode:"
    echo "    ./git-workflow.sh <common-branch> [feature-branch]"
    echo "    Example: ./git-workflow.sh dev-common feature-auth"
    echo ""
    echo "  AI Command Mode:"
    echo "    ./git-workflow.sh git-mode"
    echo "    ./git-workflow.sh ai"
    echo "    ./git-workflow.sh interactive"
    echo ""
    echo "  Show Menu:"
    echo "    ./git-workflow.sh"
    echo "    ./git-workflow.sh menu"
    echo ""
    echo -e "${YELLOW}WORKFLOW MODE:${NC}"
    echo "  Automates common branch management with conflict resolution"
    echo "  - Syncs common branch with master using rebase"
    echo "  - Integrates feature branch changes via cherry-pick or rebase"
    echo "  - Automatically resolves version conflicts in pom.xml files"
    echo "  - Handles multi-step rebase conflicts automatically"
    echo ""
    echo -e "${YELLOW}AI COMMAND MODE:${NC}"
    echo "  Interactive git assistant powered by GitHub Copilot"
    echo "  - Natural language git commands"
    echo "  - Automatic placeholder resolution"
    echo "  - Smart error handling and suggestions"
    echo ""
    echo -e "${YELLOW}OPTIONS:${NC}"
    echo "  --help, -h, help    Show this help"
    echo "  --version, -v       Show version info"
}

# Show version info
show_version() {
    echo -e "${BLUE}Git Workflow Script${NC}"
    echo "Version: 2.0.0"
    echo "Features: AI-powered conflict resolution, placeholder handling"
    echo "Dependencies: git, gh (GitHub CLI)"
}

# Handle main menu
handle_main_menu() {
    echo -e "${BLUE}üîß Git Workflow Assistant${NC}"
    echo "========================="
    echo ""
    echo "Choose a mode:"
    echo ""
    echo -e "${CYAN}1) Workflow Mode${NC} - Automated branch management"
    echo "   ‚Ä¢ Sync common branch with master"
    echo "   ‚Ä¢ Integrate feature branch changes"
    echo "   ‚Ä¢ Automatic conflict resolution"
    echo ""
    echo -e "${CYAN}2) AI Command Mode${NC} - Interactive git assistant"
    echo "   ‚Ä¢ Natural language git commands"
    echo "   ‚Ä¢ GitHub Copilot integration"
    echo "   ‚Ä¢ Smart command suggestions"
    echo ""
    echo -e "${CYAN}3) Help${NC} - Show detailed documentation"
    echo ""
    echo -e "${CYAN}4) Exit${NC} - Quit the script"
    echo ""
    read -p "Select mode (1-4): " choice
    
    case "$choice" in
        1)
            echo ""
            read -p "Enter common branch name: " common_branch
            if [ -n "$common_branch" ]; then
                read -p "Enter feature branch name (optional): " feature_branch
                check_git_repo
                main_workflow "$common_branch" "$feature_branch"
            else
                log_error "Common branch name is required"
                exit 1
            fi
            ;;
        2)
            check_git_repo
            git_command_mode
            ;;
        3)
            show_detailed_help
            ;;
        4)
            echo -e "${GREEN}üëã Goodbye!${NC}"
            exit 0
            ;;
        *)
            log_error "Invalid choice. Please select 1-4."
            exit 1
            ;;
    esac
}

# Simple workflow for basic git operations
simple_workflow() {
    local branch_name="$1"
    
    echo -e "${BLUE}üîß Simple Git Workflow${NC}"
    echo "======================="
    echo "Branch: $branch_name"
    echo ""
    
    # Basic git operations without Copilot dependency
    log_step "1" "Basic Git Operations"
    
    echo "Available operations:"
    echo "1) Create and switch to branch"
    echo "2) Switch to existing branch" 
    echo "3) Pull latest changes"
    echo "4) Push current branch"
    echo "5) Show git status"
    echo ""
    
    read -p "Select operation (1-5): " op_choice
    
    case "$op_choice" in
        1)
            execute_git "git checkout -b $branch_name" "Creating new branch"
            ;;
        2)
            execute_git "git checkout $branch_name" "Switching to branch"
            ;;
        3)
            execute_git "git pull origin $(git branch --show-current)" "Pulling latest changes"
            ;;
        4)
            execute_git "git push origin $(git branch --show-current)" "Pushing current branch"
            ;;
        5)
            execute_git "git status" "Showing git status"
            ;;
        *)
            log_error "Invalid choice"
            ;;
    esac
}

# Interactive Git Command Mode - simplified version
git_command_mode() {
    echo -e "${BLUE}ü§ñ Git Command Mode${NC}"
    echo "==================="
    echo "Enter git operations, and I'll help execute them!"
    echo ""
    echo "Examples:"
    echo "  ‚Ä¢ 'show status'"
    echo "  ‚Ä¢ 'create branch feature-auth'"
    echo "  ‚Ä¢ 'push to origin'"
    echo "  ‚Ä¢ 'pull latest'"
    echo ""
    echo "Type 'exit' to return to main menu"
    echo "================================="
    echo ""
    
    while true; do
        echo -e "${CYAN}Current branch: $(git branch --show-current)${NC}"
        echo -e "${CYAN}Status: $(git status --porcelain | wc -l) changed files${NC}"
        echo ""
        read -p "ü§ñ Git> " user_command
        
        # Handle special commands
        case "$user_command" in
            "exit"|"quit"|"q")
                log_success "Exiting Git Command Mode"
                break
                ;;
            "help"|"h")
                show_git_command_help
                continue
                ;;
            "status"|"s")
                git status
                continue
                ;;
            "")
                continue
                ;;
            *)
                # Process the command
                process_simple_git_command "$user_command"
                ;;
        esac
        
        echo ""
    done
}

# Process simple git commands
process_simple_git_command() {
    local input="$1"
    
    log_action "Processing: \"$input\""
    
    # Simple pattern matching for common commands
    local cmd=""
    case "$(echo "$input" | tr '[:upper:]' '[:lower:]')" in
        *"status"*|*"show status"*)
            cmd="git status"
            ;;
        *"create branch"*)
            local branch=$(echo "$input" | sed -n 's/.*create branch \([a-zA-Z0-9_-]\+\).*/\1/p')
            if [ -n "$branch" ]; then
                cmd="git checkout -b $branch"
            else
                read -p "Enter new branch name: " branch
                cmd="git checkout -b $branch"
            fi
            ;;
        *"switch"*|*"checkout"*)
            local branch=$(echo "$input" | grep -o '[a-zA-Z0-9_-]\+' | tail -1)
            cmd="git checkout $branch"
            ;;
        *"pull"*|*"update"*)
            cmd="git pull origin $(git branch --show-current)"
            ;;
        *"push"*)
            cmd="git push origin $(git branch --show-current)"
            ;;
        *"commit"*)
            read -p "Enter commit message: " msg
            cmd="git add . && git commit -m \"$msg\""
            ;;
        *"log"*|*"history"*)
            cmd="git log --oneline -10"
            ;;
        *)
            echo "Available commands:"
            echo "  ‚Ä¢ show status"
            echo "  ‚Ä¢ create branch <name>"
            echo "  ‚Ä¢ switch to <branch>"
            echo "  ‚Ä¢ pull latest"
            echo "  ‚Ä¢ push changes"
            echo "  ‚Ä¢ commit changes"
            echo "  ‚Ä¢ show log"
            return
            ;;
    esac
    
    if [ -n "$cmd" ]; then
        echo -e "${GREEN}üöÄ EXECUTING: $cmd${NC}"
        eval "$cmd"
        if [ $? -eq 0 ]; then
            log_success "Command executed successfully"
        else
            log_error "Command failed"
        fi
    fi
}

# Show help for git command mode
show_git_command_help() {
    echo -e "${BLUE}ü§ñ Git Command Examples${NC}"
    echo "======================="
    echo ""
    echo -e "${YELLOW}Available Commands:${NC}"
    echo "  ‚Ä¢ 'show status' - Display git status"
    echo "  ‚Ä¢ 'create branch feature-name' - Create new branch"
    echo "  ‚Ä¢ 'switch to branch-name' - Switch branches"
    echo "  ‚Ä¢ 'pull latest' - Pull from remote"
    echo "  ‚Ä¢ 'push changes' - Push to remote"
    echo "  ‚Ä¢ 'commit changes' - Add and commit"
    echo "  ‚Ä¢ 'show log' - Display commit history"
    echo ""
}

# Main workflow function with simplified operations
main_workflow() {
    local common_branch="$1"
    local feature_branch="$2"
    
    echo -e "${BLUE}üöÄ Git Workflow Mode${NC}"
    echo "===================="
    echo "Common branch: $common_branch"
    echo ""
    
    if [ -z "$feature_branch" ]; then
        echo "Mode: Basic branch operations"
        simple_workflow "$common_branch"
    else
        echo "Feature branch: $feature_branch"
        echo "Mode: Feature integration workflow"
        
        # Basic workflow without complex AI features
        log_step "1" "Switching to common branch"
        execute_git "git checkout $common_branch || git checkout -b $common_branch" "Switch to common branch"
        
        log_step "2" "Pulling latest changes"
        execute_git "git pull origin $common_branch || true" "Pull latest changes"
        
        log_step "3" "Merging feature branch"
        read -p "Merge $feature_branch into $common_branch? (Y/n): " confirm
        if [[ ! $confirm =~ ^[Nn]$ ]]; then
            execute_git "git merge $feature_branch" "Merging feature branch"
        fi
        
        log_step "4" "Pushing changes"
        read -p "Push $common_branch to origin? (Y/n): " push_confirm
        if [[ ! $push_confirm =~ ^[Nn]$ ]]; then
            execute_git "git push origin $common_branch" "Pushing to origin"
        fi
    fi
    
    echo ""
    echo -e "${GREEN}üéâ Workflow completed!${NC}"
}

# Main script execution
main() {
    local command="$1"
    local branch_or_param="$2"
    local feature_branch="$3"
    
    # Handle different modes
    case "$command" in
        "help"|"--help"|"-h")
            show_detailed_help
            exit 0
            ;;
        "--version"|"-v"|"version")
            show_version
            exit 0
            ;;
        "git-mode"|"ai"|"assistant"|"cmd"|"command"|"interactive")
            check_git_repo
            git_command_mode
            exit 0
            ;;
        "menu"|"main"|"")
            # Show main menu when no parameters or explicit menu request
            handle_main_menu
            exit 0
            ;;
        *)
            # Traditional workflow mode with parameters
            local common_branch="$command"
            local feature_branch="$branch_or_param"
            
            # Validate workflow mode parameters
            if [ -z "$common_branch" ]; then
                # No parameters provided, show main menu
                handle_main_menu
                exit 0
            fi
            
            check_git_repo
            
            # Show workflow mode header
            echo -e "${BLUE}üîß Workflow Mode - Branch Management${NC}"
            echo "====================================="
            echo "Common branch: $common_branch"
            if [ -n "$feature_branch" ]; then
                echo "Feature branch: $feature_branch"
            fi
            echo ""
            
            main_workflow "$common_branch" "$feature_branch"
            ;;
    esac
}

# Run the script
main "$@"
